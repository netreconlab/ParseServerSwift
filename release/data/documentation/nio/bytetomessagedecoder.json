{
  "abstract" : [
    {
      "code" : "ByteToMessageDecoder",
      "type" : "codeVoice"
    },
    {
      "text" : "s decode bytes in a stream-like fashion from ",
      "type" : "text"
    },
    {
      "code" : "ByteBuffer",
      "type" : "codeVoice"
    },
    {
      "text" : " to another message type.",
      "type" : "text"
    }
  ],
  "hierarchy" : {
    "paths" : [
      [
        "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIO"
      ]
    ]
  },
  "identifier" : {
    "interfaceLanguage" : "swift",
    "url" : "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIO\/ByteToMessageDecoder"
  },
  "kind" : "symbol",
  "metadata" : {
    "externalID" : "s:7NIOCore20ByteToMessageDecoderP",
    "fragments" : [
      {
        "kind" : "keyword",
        "text" : "protocol"
      },
      {
        "kind" : "text",
        "text" : " "
      },
      {
        "kind" : "identifier",
        "text" : "ByteToMessageDecoder"
      }
    ],
    "modules" : [
      {
        "name" : "NIO"
      }
    ],
    "navigatorTitle" : [
      {
        "kind" : "identifier",
        "text" : "ByteToMessageDecoder"
      }
    ],
    "role" : "symbol",
    "roleHeading" : "Protocol",
    "symbolKind" : "protocol",
    "title" : "ByteToMessageDecoder"
  },
  "primaryContentSections" : [
    {
      "declarations" : [
        {
          "languages" : [
            "swift"
          ],
          "platforms" : [
            "macOS"
          ],
          "tokens" : [
            {
              "kind" : "keyword",
              "text" : "protocol"
            },
            {
              "kind" : "text",
              "text" : " "
            },
            {
              "kind" : "identifier",
              "text" : "ByteToMessageDecoder"
            }
          ]
        }
      ],
      "kind" : "declarations"
    },
    {
      "content" : [
        {
          "anchor" : "Purpose",
          "level" : 3,
          "text" : "Purpose",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "A ",
              "type" : "text"
            },
            {
              "code" : "ByteToMessageDecoder",
              "type" : "codeVoice"
            },
            {
              "text" : " provides a simplified API for handling streams of incoming data that can be broken",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "up into messages. This API boils down to two methods: ",
              "type" : "text"
            },
            {
              "code" : "decode",
              "type" : "codeVoice"
            },
            {
              "text" : ", and ",
              "type" : "text"
            },
            {
              "code" : "decodeLast",
              "type" : "codeVoice"
            },
            {
              "text" : ". These two methods, when",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "implemented, will be used by a ",
              "type" : "text"
            },
            {
              "code" : "ByteToMessageHandler",
              "type" : "codeVoice"
            },
            {
              "text" : " paired with a ",
              "type" : "text"
            },
            {
              "code" : "ByteToMessageDecoder",
              "type" : "codeVoice"
            },
            {
              "text" : " to decode the",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "incoming byte stream into a sequence of messages.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "The reason this helper exists is to smooth away some of the boilerplate and edge case handling code that",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "is often necessary when implementing parsers in a SwiftNIO ",
              "type" : "text"
            },
            {
              "code" : "ChannelPipeline",
              "type" : "codeVoice"
            },
            {
              "text" : ". A ",
              "type" : "text"
            },
            {
              "code" : "ByteToMessageDecoder",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "never needs to worry about how inbound bytes will be buffered, as ",
              "type" : "text"
            },
            {
              "code" : "ByteToMessageHandler",
              "type" : "codeVoice"
            },
            {
              "text" : " deals with that",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "automatically. A ",
              "type" : "text"
            },
            {
              "code" : "ByteToMessageDecoder",
              "type" : "codeVoice"
            },
            {
              "text" : " also never needs to worry about memory exclusivity violations",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "that can occur when re-entrant ",
              "type" : "text"
            },
            {
              "code" : "ChannelPipeline",
              "type" : "codeVoice"
            },
            {
              "text" : " operations occur, as ",
              "type" : "text"
            },
            {
              "code" : "ByteToMessageHandler",
              "type" : "codeVoice"
            },
            {
              "text" : " will deal with",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "those as well.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "anchor" : "Implementing-ByteToMessageDecoder",
          "level" : 3,
          "text" : "Implementing ByteToMessageDecoder",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "A type that implements ",
              "type" : "text"
            },
            {
              "code" : "ByteToMessageDecoder",
              "type" : "codeVoice"
            },
            {
              "text" : " may implement two methods: decode and decodeLast. Implementations",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "must implement decode: if they do not implement decodeLast, a default implementation will be used that",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "simply calls decode.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "code" : "decode",
              "type" : "codeVoice"
            },
            {
              "text" : " is the main decoding method, and is the one that will be called most often. ",
              "type" : "text"
            },
            {
              "code" : "decode",
              "type" : "codeVoice"
            },
            {
              "text" : " is invoked",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "whenever data is received by the wrapping ",
              "type" : "text"
            },
            {
              "code" : "ByteToMessageHandler",
              "type" : "codeVoice"
            },
            {
              "text" : ". It is invoked with a ",
              "type" : "text"
            },
            {
              "code" : "ByteBuffer",
              "type" : "codeVoice"
            },
            {
              "text" : " containing",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "all the received data (including any data previously buffered), as well as a ",
              "type" : "text"
            },
            {
              "code" : "ChannelHandlerContext",
              "type" : "codeVoice"
            },
            {
              "text" : " that can be",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "used in the ",
              "type" : "text"
            },
            {
              "code" : "decode",
              "type" : "codeVoice"
            },
            {
              "text" : " function.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "code" : "decode",
              "type" : "codeVoice"
            },
            {
              "text" : " is called in a loop by the ",
              "type" : "text"
            },
            {
              "code" : "ByteToMessageHandler",
              "type" : "codeVoice"
            },
            {
              "text" : ". This loop continues until one of two cases occurs:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "items" : [
            {
              "content" : [
                {
                  "inlineContent" : [
                    {
                      "text" : "The input ",
                      "type" : "text"
                    },
                    {
                      "code" : "ByteBuffer",
                      "type" : "codeVoice"
                    },
                    {
                      "text" : " has no more readable bytes (i.e. ",
                      "type" : "text"
                    },
                    {
                      "code" : ".readableBytes == 0",
                      "type" : "codeVoice"
                    },
                    {
                      "text" : "); OR",
                      "type" : "text"
                    }
                  ],
                  "type" : "paragraph"
                }
              ]
            },
            {
              "content" : [
                {
                  "inlineContent" : [
                    {
                      "text" : "The ",
                      "type" : "text"
                    },
                    {
                      "code" : "decode",
                      "type" : "codeVoice"
                    },
                    {
                      "text" : " method returns ",
                      "type" : "text"
                    },
                    {
                      "code" : ".needMoreData",
                      "type" : "codeVoice"
                    },
                    {
                      "text" : ".",
                      "type" : "text"
                    }
                  ],
                  "type" : "paragraph"
                }
              ]
            }
          ],
          "type" : "orderedList"
        },
        {
          "inlineContent" : [
            {
              "text" : "The reason this method is invoked in a loop is to ensure that the stream-like properties of inbound data are",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "respected. It is entirely possible for ",
              "type" : "text"
            },
            {
              "code" : "ByteToMessageDecoder",
              "type" : "codeVoice"
            },
            {
              "text" : " to receive either fewer bytes than a single message,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "or multiple messages in one go. Rather than have the ",
              "type" : "text"
            },
            {
              "code" : "ByteToMessageDecoder",
              "type" : "codeVoice"
            },
            {
              "text" : " handle all of the complexity of this,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the logic can be boiled down to a single choice: has the ",
              "type" : "text"
            },
            {
              "code" : "ByteToMessageDecoder",
              "type" : "codeVoice"
            },
            {
              "text" : " been able to move the state forward",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "or not? If it has, rather than containing an internal loop it may simply return ",
              "type" : "text"
            },
            {
              "code" : ".continue",
              "type" : "codeVoice"
            },
            {
              "text" : " in order to request that",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "code" : "decode",
              "type" : "codeVoice"
            },
            {
              "text" : " be invoked again immediately. If it has not, it can return ",
              "type" : "text"
            },
            {
              "code" : ".needMoreData",
              "type" : "codeVoice"
            },
            {
              "text" : " to ask to be left alone until more",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "data has been returned from the network.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "Essentially, if the next parsing step could not be taken because there wasn’t enough data available, return ",
              "type" : "text"
            },
            {
              "code" : ".needMoreData",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Otherwise, return ",
              "type" : "text"
            },
            {
              "code" : ".continue",
              "type" : "codeVoice"
            },
            {
              "text" : ". This will allow a ",
              "type" : "text"
            },
            {
              "code" : "ByteToMessageDecoder",
              "type" : "codeVoice"
            },
            {
              "text" : " implementation to ignore the awkward way data",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "arrives from the network, and to just treat it as a series of ",
              "type" : "text"
            },
            {
              "code" : "decode",
              "type" : "codeVoice"
            },
            {
              "text" : " calls.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "code" : "decodeLast",
              "type" : "codeVoice"
            },
            {
              "text" : " is a cousin of ",
              "type" : "text"
            },
            {
              "code" : "decode",
              "type" : "codeVoice"
            },
            {
              "text" : ". It is also called in a loop, but unlike with ",
              "type" : "text"
            },
            {
              "code" : "decode",
              "type" : "codeVoice"
            },
            {
              "text" : " this loop will only ever",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "occur once: when the ",
              "type" : "text"
            },
            {
              "code" : "ChannelHandlerContext",
              "type" : "codeVoice"
            },
            {
              "text" : " belonging to this ",
              "type" : "text"
            },
            {
              "code" : "ByteToMessageDecoder",
              "type" : "codeVoice"
            },
            {
              "text" : " is about to become invalidated.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "This invalidation happens in two situations: when EOF is received from the network, or when the ",
              "type" : "text"
            },
            {
              "code" : "ByteToMessageDecoder",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "is being removed from the ",
              "type" : "text"
            },
            {
              "code" : "ChannelPipeline",
              "type" : "codeVoice"
            },
            {
              "text" : ". The distinction between these two states is captured by the value of",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "code" : "seenEOF",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "In this condition, the ",
              "type" : "text"
            },
            {
              "code" : "ByteToMessageDecoder",
              "type" : "codeVoice"
            },
            {
              "text" : " must now produce any final messages it can with the bytes it has",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "available. In protocols where EOF is used as a message delimiter, having ",
              "type" : "text"
            },
            {
              "code" : "decodeLast",
              "type" : "codeVoice"
            },
            {
              "text" : " called with ",
              "type" : "text"
            },
            {
              "code" : "seenEOF == true",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "may produce further messages. In other cases, ",
              "type" : "text"
            },
            {
              "code" : "decodeLast",
              "type" : "codeVoice"
            },
            {
              "text" : " may choose to deliver any buffered bytes as “leftovers”,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "either in error messages or via ",
              "type" : "text"
            },
            {
              "code" : "channelRead",
              "type" : "codeVoice"
            },
            {
              "text" : ". This can occur if, for example, a protocol upgrade is occurring.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "As with ",
              "type" : "text"
            },
            {
              "code" : "decode",
              "type" : "codeVoice"
            },
            {
              "text" : ", ",
              "type" : "text"
            },
            {
              "code" : "decodeLast",
              "type" : "codeVoice"
            },
            {
              "text" : " is invoked in a loop. This allows the same simplification as ",
              "type" : "text"
            },
            {
              "code" : "decode",
              "type" : "codeVoice"
            },
            {
              "text" : " allows: when",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "a message is completely parsed, the ",
              "type" : "text"
            },
            {
              "code" : "decodeLast",
              "type" : "codeVoice"
            },
            {
              "text" : " function can return ",
              "type" : "text"
            },
            {
              "code" : ".continue",
              "type" : "codeVoice"
            },
            {
              "text" : " and be re-invoked from the top,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "rather than containing an internal loop.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "Note that the value of ",
              "type" : "text"
            },
            {
              "code" : "seenEOF",
              "type" : "codeVoice"
            },
            {
              "text" : " may change between calls to ",
              "type" : "text"
            },
            {
              "code" : "decodeLast",
              "type" : "codeVoice"
            },
            {
              "text" : " in some rare situations.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "anchor" : "Implementers-Notes",
          "level" : 3,
          "text" : "Implementers Notes",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "code" : "ByteToMessageHandler",
              "type" : "codeVoice"
            },
            {
              "text" : " will turn your ",
              "type" : "text"
            },
            {
              "code" : "ByteToMessageDecoder",
              "type" : "codeVoice"
            },
            {
              "text" : " into a ",
              "type" : "text"
            },
            {
              "code" : "ChannelInboundHandler",
              "type" : "codeVoice"
            },
            {
              "text" : ". ",
              "type" : "text"
            },
            {
              "code" : "ByteToMessageHandler",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "also solves a couple of tricky issues for you. Most importantly, in a ",
              "type" : "text"
            },
            {
              "code" : "ByteToMessageDecoder",
              "type" : "codeVoice"
            },
            {
              "text" : " you do ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "not",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " need to",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "worry about re-entrancy. Your code owns the passed-in ",
              "type" : "text"
            },
            {
              "code" : "ByteBuffer",
              "type" : "codeVoice"
            },
            {
              "text" : " for the duration of the ",
              "type" : "text"
            },
            {
              "code" : "decode",
              "type" : "codeVoice"
            },
            {
              "text" : "\/",
              "type" : "text"
            },
            {
              "code" : "decodeLast",
              "type" : "codeVoice"
            },
            {
              "text" : " call and",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "can modify it at will.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "If a custom frame decoder is required, then one needs to be careful when implementing",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "one with ",
              "type" : "text"
            },
            {
              "code" : "ByteToMessageDecoder",
              "type" : "codeVoice"
            },
            {
              "text" : ". Ensure there are enough bytes in the buffer for a",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "complete frame by checking ",
              "type" : "text"
            },
            {
              "code" : "buffer.readableBytes",
              "type" : "codeVoice"
            },
            {
              "text" : ". If there are not enough bytes",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "for a complete frame, return without modifying the reader index to allow more bytes to arrive.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "To check for complete frames without modifying the reader index, use methods like ",
              "type" : "text"
            },
            {
              "code" : "buffer.getInteger",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "You  ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "MUST",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " use the reader index when using methods like ",
              "type" : "text"
            },
            {
              "code" : "buffer.getInteger",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "For example calling ",
              "type" : "text"
            },
            {
              "code" : "buffer.getInteger(at: 0)",
              "type" : "codeVoice"
            },
            {
              "text" : " is assuming the frame starts at the beginning of the buffer, which",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "is not always the case. Use ",
              "type" : "text"
            },
            {
              "code" : "buffer.getInteger(at: buffer.readerIndex)",
              "type" : "codeVoice"
            },
            {
              "text" : " instead.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "If you move the reader index forward, either manually or by using one of ",
              "type" : "text"
            },
            {
              "code" : "buffer.read*",
              "type" : "codeVoice"
            },
            {
              "text" : " methods, you must ensure",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "that you no longer need to see those bytes again as they will not be returned to you the next time ",
              "type" : "text"
            },
            {
              "code" : "decode",
              "type" : "codeVoice"
            },
            {
              "text" : " is",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "called. If you still need those bytes to come back, consider taking a local copy of buffer inside the function to",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "perform your read operations on.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "code" : "ByteBuffer",
              "type" : "codeVoice"
            },
            {
              "text" : " passed in as ",
              "type" : "text"
            },
            {
              "code" : "buffer",
              "type" : "codeVoice"
            },
            {
              "text" : " is a slice of a larger buffer owned by the ",
              "type" : "text"
            },
            {
              "code" : "ByteToMessageDecoder",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "implementation. Some aspects of this buffer are preserved across calls to ",
              "type" : "text"
            },
            {
              "code" : "decode",
              "type" : "codeVoice"
            },
            {
              "text" : ", meaning that any changes to",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "those properties you make in your ",
              "type" : "text"
            },
            {
              "code" : "decode",
              "type" : "codeVoice"
            },
            {
              "text" : " method will be reflected in the next call to decode. In particular,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "moving the reader index forward persists across calls. When your method returns, if the reader index has advanced,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "those bytes are considered “consumed” and will not be available in future calls to ",
              "type" : "text"
            },
            {
              "code" : "decode",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Please note, however, that the numerical value of the ",
              "type" : "text"
            },
            {
              "code" : "readerIndex",
              "type" : "codeVoice"
            },
            {
              "text" : " itself is not preserved, and may not be the same",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "from one call to the next. Please do not rely on this numerical value: if you need",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "to recall where a byte is relative to the ",
              "type" : "text"
            },
            {
              "code" : "readerIndex",
              "type" : "codeVoice"
            },
            {
              "text" : ", use an offset rather than an absolute value.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "anchor" : "Using-ByteToMessageDecoder",
          "level" : 3,
          "text" : "Using ByteToMessageDecoder",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "To add a ",
              "type" : "text"
            },
            {
              "code" : "ByteToMessageDecoder",
              "type" : "codeVoice"
            },
            {
              "text" : " to the ",
              "type" : "text"
            },
            {
              "code" : "ChannelPipeline",
              "type" : "codeVoice"
            },
            {
              "text" : " use",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "channel.pipeline.addHandler(ByteToMessageHandler(MyByteToMessageDecoder()))"
          ],
          "syntax" : null,
          "type" : "codeListing"
        }
      ],
      "kind" : "content"
    }
  ],
  "relationshipsSections" : [
    {
      "identifiers" : [
        "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIO\/NIOSingleStepByteToMessageDecoder",
        "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIO\/WriteObservingByteToMessageDecoder"
      ],
      "kind" : "relationships",
      "title" : "Inherited By",
      "type" : "inheritedBy"
    },
    {
      "identifiers" : [
        "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIOExtras\/FixedLengthFrameDecoder",
        "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIOHTTP1\/HTTPDecoder",
        "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIOExtras\/LengthFieldBasedFrameDecoder",
        "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIOExtras\/LineBasedFrameDecoder",
        "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIOExtras\/NIOJSONRPCFraming\/ContentLengthHeaderFrameDecoder",
        "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIOTLS\/SNIHandler",
        "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIOWebSocket\/WebSocketFrameDecoder"
      ],
      "kind" : "relationships",
      "title" : "Conforming Types",
      "type" : "conformingTypes"
    }
  ],
  "schemaVersion" : {
    "major" : 0,
    "minor" : 3,
    "patch" : 0
  },
  "sections" : [

  ],
  "topicSections" : [
    {
      "identifiers" : [
        "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIO\/ByteToMessageDecoder\/InboundOut"
      ],
      "title" : "Associated Types"
    },
    {
      "identifiers" : [
        "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIO\/ByteToMessageDecoder\/decode(context:buffer:)-659ji",
        "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIO\/ByteToMessageDecoder\/decodeLast(context:buffer:seenEOF:)-1tkzf",
        "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIO\/ByteToMessageDecoder\/decoderAdded(context:)-7trzq",
        "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIO\/ByteToMessageDecoder\/decoderRemoved(context:)-sa8l",
        "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIO\/ByteToMessageDecoder\/shouldReclaimBytes(buffer:)-5fn2u",
        "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIO\/ByteToMessageDecoder\/wrapInboundOut(_:)"
      ],
      "title" : "Instance Methods"
    }
  ],
  "variants" : [
    {
      "paths" : [
        "\/documentation\/nio\/bytetomessagedecoder"
      ],
      "traits" : [
        {
          "interfaceLanguage" : "swift"
        }
      ]
    }
  ]
, 
"references": {
"doc://edu.uky.cs.netreconlab.ParseServerSwift/documentation/NIO": {
  "abstract" : [

  ],
  "identifier" : "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIO",
  "kind" : "symbol",
  "role" : "collection",
  "title" : "NIO",
  "type" : "topic",
  "url" : "\/documentation\/nio"
},
"doc://edu.uky.cs.netreconlab.ParseServerSwift/documentation/NIO/ByteToMessageDecoder": {
  "abstract" : [
    {
      "code" : "ByteToMessageDecoder",
      "type" : "codeVoice"
    },
    {
      "text" : "s decode bytes in a stream-like fashion from ",
      "type" : "text"
    },
    {
      "code" : "ByteBuffer",
      "type" : "codeVoice"
    },
    {
      "text" : " to another message type.",
      "type" : "text"
    }
  ],
  "fragments" : [
    {
      "kind" : "keyword",
      "text" : "protocol"
    },
    {
      "kind" : "text",
      "text" : " "
    },
    {
      "kind" : "identifier",
      "text" : "ByteToMessageDecoder"
    }
  ],
  "identifier" : "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIO\/ByteToMessageDecoder",
  "kind" : "symbol",
  "navigatorTitle" : [
    {
      "kind" : "identifier",
      "text" : "ByteToMessageDecoder"
    }
  ],
  "role" : "symbol",
  "title" : "ByteToMessageDecoder",
  "type" : "topic",
  "url" : "\/documentation\/nio\/bytetomessagedecoder"
},
"doc://edu.uky.cs.netreconlab.ParseServerSwift/documentation/NIO/ByteToMessageDecoder/InboundOut": {
  "abstract" : [
    {
      "text" : "The type of the messages this ",
      "type" : "text"
    },
    {
      "code" : "ByteToMessageDecoder",
      "type" : "codeVoice"
    },
    {
      "text" : " decodes to.",
      "type" : "text"
    }
  ],
  "fragments" : [
    {
      "kind" : "keyword",
      "text" : "associatedtype"
    },
    {
      "kind" : "text",
      "text" : " "
    },
    {
      "kind" : "identifier",
      "text" : "InboundOut"
    }
  ],
  "identifier" : "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIO\/ByteToMessageDecoder\/InboundOut",
  "kind" : "symbol",
  "required" : true,
  "role" : "symbol",
  "title" : "InboundOut",
  "type" : "topic",
  "url" : "\/documentation\/nio\/bytetomessagedecoder\/inboundout"
},
"doc://edu.uky.cs.netreconlab.ParseServerSwift/documentation/NIO/ByteToMessageDecoder/decode(context:buffer:)-659ji": {
  "abstract" : [
    {
      "text" : "Decode from a ",
      "type" : "text"
    },
    {
      "code" : "ByteBuffer",
      "type" : "codeVoice"
    },
    {
      "text" : ".",
      "type" : "text"
    }
  ],
  "defaultImplementations" : 2,
  "fragments" : [
    {
      "kind" : "keyword",
      "text" : "func"
    },
    {
      "kind" : "text",
      "text" : " "
    },
    {
      "kind" : "identifier",
      "text" : "decode"
    },
    {
      "kind" : "text",
      "text" : "("
    },
    {
      "kind" : "externalParam",
      "text" : "context"
    },
    {
      "kind" : "text",
      "text" : ": "
    },
    {
      "kind" : "typeIdentifier",
      "preciseIdentifier" : "s:7NIOCore21ChannelHandlerContextC",
      "text" : "ChannelHandlerContext"
    },
    {
      "kind" : "text",
      "text" : ", "
    },
    {
      "kind" : "externalParam",
      "text" : "buffer"
    },
    {
      "kind" : "text",
      "text" : ": "
    },
    {
      "kind" : "keyword",
      "text" : "inout"
    },
    {
      "kind" : "text",
      "text" : " "
    },
    {
      "kind" : "typeIdentifier",
      "preciseIdentifier" : "s:7NIOCore10ByteBufferV",
      "text" : "ByteBuffer"
    },
    {
      "kind" : "text",
      "text" : ") "
    },
    {
      "kind" : "keyword",
      "text" : "throws"
    },
    {
      "kind" : "text",
      "text" : " -> "
    },
    {
      "kind" : "typeIdentifier",
      "preciseIdentifier" : "s:7NIOCore13DecodingStateO",
      "text" : "DecodingState"
    }
  ],
  "identifier" : "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIO\/ByteToMessageDecoder\/decode(context:buffer:)-659ji",
  "kind" : "symbol",
  "required" : true,
  "role" : "symbol",
  "title" : "decode(context:buffer:)",
  "type" : "topic",
  "url" : "\/documentation\/nio\/bytetomessagedecoder\/decode(context:buffer:)-659ji"
},
"doc://edu.uky.cs.netreconlab.ParseServerSwift/documentation/NIO/ByteToMessageDecoder/decodeLast(context:buffer:seenEOF:)-1tkzf": {
  "abstract" : [
    {
      "text" : "Decode from a ",
      "type" : "text"
    },
    {
      "code" : "ByteBuffer",
      "type" : "codeVoice"
    },
    {
      "text" : " when no more data is incoming and the ",
      "type" : "text"
    },
    {
      "code" : "ByteToMessageDecoder",
      "type" : "codeVoice"
    },
    {
      "text" : " is about to leave",
      "type" : "text"
    },
    {
      "text" : " ",
      "type" : "text"
    },
    {
      "text" : "the pipeline.",
      "type" : "text"
    }
  ],
  "defaultImplementations" : 4,
  "fragments" : [
    {
      "kind" : "keyword",
      "text" : "func"
    },
    {
      "kind" : "text",
      "text" : " "
    },
    {
      "kind" : "identifier",
      "text" : "decodeLast"
    },
    {
      "kind" : "text",
      "text" : "("
    },
    {
      "kind" : "externalParam",
      "text" : "context"
    },
    {
      "kind" : "text",
      "text" : ": "
    },
    {
      "kind" : "typeIdentifier",
      "preciseIdentifier" : "s:7NIOCore21ChannelHandlerContextC",
      "text" : "ChannelHandlerContext"
    },
    {
      "kind" : "text",
      "text" : ", "
    },
    {
      "kind" : "externalParam",
      "text" : "buffer"
    },
    {
      "kind" : "text",
      "text" : ": "
    },
    {
      "kind" : "keyword",
      "text" : "inout"
    },
    {
      "kind" : "text",
      "text" : " "
    },
    {
      "kind" : "typeIdentifier",
      "preciseIdentifier" : "s:7NIOCore10ByteBufferV",
      "text" : "ByteBuffer"
    },
    {
      "kind" : "text",
      "text" : ", "
    },
    {
      "kind" : "externalParam",
      "text" : "seenEOF"
    },
    {
      "kind" : "text",
      "text" : ": "
    },
    {
      "kind" : "typeIdentifier",
      "preciseIdentifier" : "s:Sb",
      "text" : "Bool"
    },
    {
      "kind" : "text",
      "text" : ") "
    },
    {
      "kind" : "keyword",
      "text" : "throws"
    },
    {
      "kind" : "text",
      "text" : " -> "
    },
    {
      "kind" : "typeIdentifier",
      "preciseIdentifier" : "s:7NIOCore13DecodingStateO",
      "text" : "DecodingState"
    }
  ],
  "identifier" : "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIO\/ByteToMessageDecoder\/decodeLast(context:buffer:seenEOF:)-1tkzf",
  "kind" : "symbol",
  "required" : true,
  "role" : "symbol",
  "title" : "decodeLast(context:buffer:seenEOF:)",
  "type" : "topic",
  "url" : "\/documentation\/nio\/bytetomessagedecoder\/decodelast(context:buffer:seeneof:)-1tkzf"
},
"doc://edu.uky.cs.netreconlab.ParseServerSwift/documentation/NIO/ByteToMessageDecoder/decoderAdded(context:)-7trzq": {
  "abstract" : [
    {
      "text" : "Called when this ",
      "type" : "text"
    },
    {
      "code" : "ByteToMessageDecoder",
      "type" : "codeVoice"
    },
    {
      "text" : " is added to the ",
      "type" : "text"
    },
    {
      "code" : "ChannelPipeline",
      "type" : "codeVoice"
    },
    {
      "text" : ".",
      "type" : "text"
    }
  ],
  "defaultImplementations" : 2,
  "fragments" : [
    {
      "kind" : "keyword",
      "text" : "func"
    },
    {
      "kind" : "text",
      "text" : " "
    },
    {
      "kind" : "identifier",
      "text" : "decoderAdded"
    },
    {
      "kind" : "text",
      "text" : "("
    },
    {
      "kind" : "externalParam",
      "text" : "context"
    },
    {
      "kind" : "text",
      "text" : ": "
    },
    {
      "kind" : "typeIdentifier",
      "preciseIdentifier" : "s:7NIOCore21ChannelHandlerContextC",
      "text" : "ChannelHandlerContext"
    },
    {
      "kind" : "text",
      "text" : ")"
    }
  ],
  "identifier" : "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIO\/ByteToMessageDecoder\/decoderAdded(context:)-7trzq",
  "kind" : "symbol",
  "required" : true,
  "role" : "symbol",
  "title" : "decoderAdded(context:)",
  "type" : "topic",
  "url" : "\/documentation\/nio\/bytetomessagedecoder\/decoderadded(context:)-7trzq"
},
"doc://edu.uky.cs.netreconlab.ParseServerSwift/documentation/NIO/ByteToMessageDecoder/decoderRemoved(context:)-sa8l": {
  "abstract" : [
    {
      "text" : "Called once this ",
      "type" : "text"
    },
    {
      "code" : "ByteToMessageDecoder",
      "type" : "codeVoice"
    },
    {
      "text" : " is removed from the ",
      "type" : "text"
    },
    {
      "code" : "ChannelPipeline",
      "type" : "codeVoice"
    },
    {
      "text" : ".",
      "type" : "text"
    }
  ],
  "defaultImplementations" : 2,
  "fragments" : [
    {
      "kind" : "keyword",
      "text" : "func"
    },
    {
      "kind" : "text",
      "text" : " "
    },
    {
      "kind" : "identifier",
      "text" : "decoderRemoved"
    },
    {
      "kind" : "text",
      "text" : "("
    },
    {
      "kind" : "externalParam",
      "text" : "context"
    },
    {
      "kind" : "text",
      "text" : ": "
    },
    {
      "kind" : "typeIdentifier",
      "preciseIdentifier" : "s:7NIOCore21ChannelHandlerContextC",
      "text" : "ChannelHandlerContext"
    },
    {
      "kind" : "text",
      "text" : ")"
    }
  ],
  "identifier" : "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIO\/ByteToMessageDecoder\/decoderRemoved(context:)-sa8l",
  "kind" : "symbol",
  "required" : true,
  "role" : "symbol",
  "title" : "decoderRemoved(context:)",
  "type" : "topic",
  "url" : "\/documentation\/nio\/bytetomessagedecoder\/decoderremoved(context:)-sa8l"
},
"doc://edu.uky.cs.netreconlab.ParseServerSwift/documentation/NIO/ByteToMessageDecoder/shouldReclaimBytes(buffer:)-5fn2u": {
  "abstract" : [
    {
      "text" : "Determine if the read bytes in the given ",
      "type" : "text"
    },
    {
      "code" : "ByteBuffer",
      "type" : "codeVoice"
    },
    {
      "text" : " should be reclaimed and their associated memory freed.",
      "type" : "text"
    },
    {
      "text" : " ",
      "type" : "text"
    },
    {
      "text" : "Be aware that reclaiming memory may involve memory copies and so is not free.",
      "type" : "text"
    }
  ],
  "defaultImplementations" : 2,
  "fragments" : [
    {
      "kind" : "keyword",
      "text" : "func"
    },
    {
      "kind" : "text",
      "text" : " "
    },
    {
      "kind" : "identifier",
      "text" : "shouldReclaimBytes"
    },
    {
      "kind" : "text",
      "text" : "("
    },
    {
      "kind" : "externalParam",
      "text" : "buffer"
    },
    {
      "kind" : "text",
      "text" : ": "
    },
    {
      "kind" : "typeIdentifier",
      "preciseIdentifier" : "s:7NIOCore10ByteBufferV",
      "text" : "ByteBuffer"
    },
    {
      "kind" : "text",
      "text" : ") -> "
    },
    {
      "kind" : "typeIdentifier",
      "preciseIdentifier" : "s:Sb",
      "text" : "Bool"
    }
  ],
  "identifier" : "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIO\/ByteToMessageDecoder\/shouldReclaimBytes(buffer:)-5fn2u",
  "kind" : "symbol",
  "required" : true,
  "role" : "symbol",
  "title" : "shouldReclaimBytes(buffer:)",
  "type" : "topic",
  "url" : "\/documentation\/nio\/bytetomessagedecoder\/shouldreclaimbytes(buffer:)-5fn2u"
},
"doc://edu.uky.cs.netreconlab.ParseServerSwift/documentation/NIO/ByteToMessageDecoder/wrapInboundOut(_:)": {
  "abstract" : [

  ],
  "fragments" : [
    {
      "kind" : "keyword",
      "text" : "func"
    },
    {
      "kind" : "text",
      "text" : " "
    },
    {
      "kind" : "identifier",
      "text" : "wrapInboundOut"
    },
    {
      "kind" : "text",
      "text" : "("
    },
    {
      "kind" : "typeIdentifier",
      "text" : "Self"
    },
    {
      "kind" : "text",
      "text" : "."
    },
    {
      "kind" : "typeIdentifier",
      "text" : "InboundOut"
    },
    {
      "kind" : "text",
      "text" : ") -> "
    },
    {
      "kind" : "typeIdentifier",
      "preciseIdentifier" : "s:7NIOCore6NIOAnyV",
      "text" : "NIOAny"
    }
  ],
  "identifier" : "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIO\/ByteToMessageDecoder\/wrapInboundOut(_:)",
  "kind" : "symbol",
  "role" : "symbol",
  "title" : "wrapInboundOut(_:)",
  "type" : "topic",
  "url" : "\/documentation\/nio\/bytetomessagedecoder\/wrapinboundout(_:)"
},
"doc://edu.uky.cs.netreconlab.ParseServerSwift/documentation/NIO/NIOSingleStepByteToMessageDecoder": {
  "abstract" : [
    {
      "text" : "A simplified version of ",
      "type" : "text"
    },
    {
      "code" : "ByteToMessageDecoder",
      "type" : "codeVoice"
    },
    {
      "text" : " that can generate zero or one messages for each invocation of ",
      "type" : "text"
    },
    {
      "code" : "decode",
      "type" : "codeVoice"
    },
    {
      "text" : " or ",
      "type" : "text"
    },
    {
      "code" : "decodeLast",
      "type" : "codeVoice"
    },
    {
      "text" : ".",
      "type" : "text"
    },
    {
      "text" : " ",
      "type" : "text"
    },
    {
      "text" : "Having ",
      "type" : "text"
    },
    {
      "code" : "decode",
      "type" : "codeVoice"
    },
    {
      "text" : " and ",
      "type" : "text"
    },
    {
      "code" : "decodeLast",
      "type" : "codeVoice"
    },
    {
      "text" : " return an optional message avoids re-entrancy problems, since the functions relinquish exclusive access",
      "type" : "text"
    },
    {
      "text" : " ",
      "type" : "text"
    },
    {
      "text" : "to the ",
      "type" : "text"
    },
    {
      "code" : "ByteBuffer",
      "type" : "codeVoice"
    },
    {
      "text" : " when returning. This allows for greatly simplified processing.",
      "type" : "text"
    }
  ],
  "fragments" : [
    {
      "kind" : "keyword",
      "text" : "protocol"
    },
    {
      "kind" : "text",
      "text" : " "
    },
    {
      "kind" : "identifier",
      "text" : "NIOSingleStepByteToMessageDecoder"
    }
  ],
  "identifier" : "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIO\/NIOSingleStepByteToMessageDecoder",
  "kind" : "symbol",
  "navigatorTitle" : [
    {
      "kind" : "identifier",
      "text" : "NIOSingleStepByteToMessageDecoder"
    }
  ],
  "role" : "symbol",
  "title" : "NIOSingleStepByteToMessageDecoder",
  "type" : "topic",
  "url" : "\/documentation\/nio\/niosinglestepbytetomessagedecoder"
},
"doc://edu.uky.cs.netreconlab.ParseServerSwift/documentation/NIO/WriteObservingByteToMessageDecoder": {
  "abstract" : [
    {
      "text" : "Some ",
      "type" : "text"
    },
    {
      "code" : "ByteToMessageDecoder",
      "type" : "codeVoice"
    },
    {
      "text" : "s need to observe ",
      "type" : "text"
    },
    {
      "code" : "write",
      "type" : "codeVoice"
    },
    {
      "text" : "s (which are outbound events). ",
      "type" : "text"
    },
    {
      "code" : "ByteToMessageDecoder",
      "type" : "codeVoice"
    },
    {
      "text" : "s which",
      "type" : "text"
    },
    {
      "text" : " ",
      "type" : "text"
    },
    {
      "text" : "implement the ",
      "type" : "text"
    },
    {
      "code" : "WriteObservingByteToMessageDecoder",
      "type" : "codeVoice"
    },
    {
      "text" : " protocol will be notified about every outbound write.",
      "type" : "text"
    }
  ],
  "fragments" : [
    {
      "kind" : "keyword",
      "text" : "protocol"
    },
    {
      "kind" : "text",
      "text" : " "
    },
    {
      "kind" : "identifier",
      "text" : "WriteObservingByteToMessageDecoder"
    }
  ],
  "identifier" : "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIO\/WriteObservingByteToMessageDecoder",
  "kind" : "symbol",
  "navigatorTitle" : [
    {
      "kind" : "identifier",
      "text" : "WriteObservingByteToMessageDecoder"
    }
  ],
  "role" : "symbol",
  "title" : "WriteObservingByteToMessageDecoder",
  "type" : "topic",
  "url" : "\/documentation\/nio\/writeobservingbytetomessagedecoder"
},
"doc://edu.uky.cs.netreconlab.ParseServerSwift/documentation/NIOExtras/FixedLengthFrameDecoder": {
  "abstract" : [
    {
      "text" : "A decoder that splits the received ",
      "type" : "text"
    },
    {
      "code" : "ByteBuffer",
      "type" : "codeVoice"
    },
    {
      "text" : " by a fixed number",
      "type" : "text"
    },
    {
      "text" : " ",
      "type" : "text"
    },
    {
      "text" : "of bytes. For example, if you received the following four fragmented packets:",
      "type" : "text"
    }
  ],
  "fragments" : [
    {
      "kind" : "keyword",
      "text" : "class"
    },
    {
      "kind" : "text",
      "text" : " "
    },
    {
      "kind" : "identifier",
      "text" : "FixedLengthFrameDecoder"
    }
  ],
  "identifier" : "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIOExtras\/FixedLengthFrameDecoder",
  "kind" : "symbol",
  "navigatorTitle" : [
    {
      "kind" : "identifier",
      "text" : "FixedLengthFrameDecoder"
    }
  ],
  "role" : "symbol",
  "title" : "FixedLengthFrameDecoder",
  "type" : "topic",
  "url" : "\/documentation\/nioextras\/fixedlengthframedecoder"
},
"doc://edu.uky.cs.netreconlab.ParseServerSwift/documentation/NIOExtras/LengthFieldBasedFrameDecoder": {
  "abstract" : [
    {
      "text" : "A decoder that splits the received ",
      "type" : "text"
    },
    {
      "code" : "ByteBuffer",
      "type" : "codeVoice"
    },
    {
      "text" : " by the number of bytes specified in a fixed length header",
      "type" : "text"
    },
    {
      "text" : " ",
      "type" : "text"
    },
    {
      "text" : "contained within the buffer.",
      "type" : "text"
    }
  ],
  "fragments" : [
    {
      "kind" : "keyword",
      "text" : "class"
    },
    {
      "kind" : "text",
      "text" : " "
    },
    {
      "kind" : "identifier",
      "text" : "LengthFieldBasedFrameDecoder"
    }
  ],
  "identifier" : "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIOExtras\/LengthFieldBasedFrameDecoder",
  "kind" : "symbol",
  "navigatorTitle" : [
    {
      "kind" : "identifier",
      "text" : "LengthFieldBasedFrameDecoder"
    }
  ],
  "role" : "symbol",
  "title" : "LengthFieldBasedFrameDecoder",
  "type" : "topic",
  "url" : "\/documentation\/nioextras\/lengthfieldbasedframedecoder"
},
"doc://edu.uky.cs.netreconlab.ParseServerSwift/documentation/NIOExtras/LineBasedFrameDecoder": {
  "abstract" : [
    {
      "text" : "A decoder that splits incoming ",
      "type" : "text"
    },
    {
      "code" : "ByteBuffer",
      "type" : "codeVoice"
    },
    {
      "text" : "s around line end",
      "type" : "text"
    },
    {
      "text" : " ",
      "type" : "text"
    },
    {
      "text" : "character(s) (",
      "type" : "text"
    },
    {
      "code" : "'\\n'",
      "type" : "codeVoice"
    },
    {
      "text" : " or ",
      "type" : "text"
    },
    {
      "code" : "'\\r\\n'",
      "type" : "codeVoice"
    },
    {
      "text" : ").",
      "type" : "text"
    }
  ],
  "fragments" : [
    {
      "kind" : "keyword",
      "text" : "class"
    },
    {
      "kind" : "text",
      "text" : " "
    },
    {
      "kind" : "identifier",
      "text" : "LineBasedFrameDecoder"
    }
  ],
  "identifier" : "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIOExtras\/LineBasedFrameDecoder",
  "kind" : "symbol",
  "navigatorTitle" : [
    {
      "kind" : "identifier",
      "text" : "LineBasedFrameDecoder"
    }
  ],
  "role" : "symbol",
  "title" : "LineBasedFrameDecoder",
  "type" : "topic",
  "url" : "\/documentation\/nioextras\/linebasedframedecoder"
},
"doc://edu.uky.cs.netreconlab.ParseServerSwift/documentation/NIOExtras/NIOJSONRPCFraming/ContentLengthHeaderFrameDecoder": {
  "abstract" : [
    {
      "identifier" : "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIOExtras\/NIOJSONRPCFraming\/ContentLengthHeaderFrameDecoder",
      "isActive" : true,
      "type" : "reference"
    },
    {
      "text" : " is responsible for parsing JSON-RPC wire protocol with ‘Content-Length’",
      "type" : "text"
    },
    {
      "text" : " ",
      "type" : "text"
    },
    {
      "text" : "HTTP-like headers as used by for example by LSP (Language Server Protocol).",
      "type" : "text"
    }
  ],
  "fragments" : [
    {
      "kind" : "keyword",
      "text" : "struct"
    },
    {
      "kind" : "text",
      "text" : " "
    },
    {
      "kind" : "identifier",
      "text" : "ContentLengthHeaderFrameDecoder"
    }
  ],
  "identifier" : "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIOExtras\/NIOJSONRPCFraming\/ContentLengthHeaderFrameDecoder",
  "kind" : "symbol",
  "navigatorTitle" : [
    {
      "kind" : "identifier",
      "text" : "ContentLengthHeaderFrameDecoder"
    }
  ],
  "role" : "symbol",
  "title" : "NIOJSONRPCFraming.ContentLengthHeaderFrameDecoder",
  "type" : "topic",
  "url" : "\/documentation\/nioextras\/niojsonrpcframing\/contentlengthheaderframedecoder"
},
"doc://edu.uky.cs.netreconlab.ParseServerSwift/documentation/NIOHTTP1/HTTPDecoder": {
  "abstract" : [
    {
      "text" : "A ",
      "type" : "text"
    },
    {
      "code" : "ChannelInboundHandler",
      "type" : "codeVoice"
    },
    {
      "text" : " that parses HTTP\/1-style messages, converting them from",
      "type" : "text"
    },
    {
      "text" : " ",
      "type" : "text"
    },
    {
      "text" : "unstructured bytes to a sequence of HTTP messages.",
      "type" : "text"
    }
  ],
  "fragments" : [
    {
      "kind" : "keyword",
      "text" : "class"
    },
    {
      "kind" : "text",
      "text" : " "
    },
    {
      "kind" : "identifier",
      "text" : "HTTPDecoder"
    }
  ],
  "identifier" : "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIOHTTP1\/HTTPDecoder",
  "kind" : "symbol",
  "navigatorTitle" : [
    {
      "kind" : "identifier",
      "text" : "HTTPDecoder"
    }
  ],
  "role" : "symbol",
  "title" : "HTTPDecoder",
  "type" : "topic",
  "url" : "\/documentation\/niohttp1\/httpdecoder"
},
"doc://edu.uky.cs.netreconlab.ParseServerSwift/documentation/NIOTLS/SNIHandler": {
  "abstract" : [
    {
      "text" : "A channel handler that can be used to arbitrarily edit a channel",
      "type" : "text"
    },
    {
      "text" : " ",
      "type" : "text"
    },
    {
      "text" : "pipeline based on the hostname requested in the Server Name Indication",
      "type" : "text"
    },
    {
      "text" : " ",
      "type" : "text"
    },
    {
      "text" : "portion of the TLS Client Hello.",
      "type" : "text"
    }
  ],
  "fragments" : [
    {
      "kind" : "keyword",
      "text" : "class"
    },
    {
      "kind" : "text",
      "text" : " "
    },
    {
      "kind" : "identifier",
      "text" : "SNIHandler"
    }
  ],
  "identifier" : "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIOTLS\/SNIHandler",
  "kind" : "symbol",
  "navigatorTitle" : [
    {
      "kind" : "identifier",
      "text" : "SNIHandler"
    }
  ],
  "role" : "symbol",
  "title" : "SNIHandler",
  "type" : "topic",
  "url" : "\/documentation\/niotls\/snihandler"
},
"doc://edu.uky.cs.netreconlab.ParseServerSwift/documentation/NIOWebSocket/WebSocketFrameDecoder": {
  "abstract" : [
    {
      "text" : "An inbound ",
      "type" : "text"
    },
    {
      "code" : "ChannelHandler",
      "type" : "codeVoice"
    },
    {
      "text" : " that deserializes websocket frames into a structured",
      "type" : "text"
    },
    {
      "text" : " ",
      "type" : "text"
    },
    {
      "text" : "format for further processing.",
      "type" : "text"
    }
  ],
  "fragments" : [
    {
      "kind" : "keyword",
      "text" : "class"
    },
    {
      "kind" : "text",
      "text" : " "
    },
    {
      "kind" : "identifier",
      "text" : "WebSocketFrameDecoder"
    }
  ],
  "identifier" : "doc:\/\/edu.uky.cs.netreconlab.ParseServerSwift\/documentation\/NIOWebSocket\/WebSocketFrameDecoder",
  "kind" : "symbol",
  "navigatorTitle" : [
    {
      "kind" : "identifier",
      "text" : "WebSocketFrameDecoder"
    }
  ],
  "role" : "symbol",
  "title" : "WebSocketFrameDecoder",
  "type" : "topic",
  "url" : "\/documentation\/niowebsocket\/websocketframedecoder"
}
}
}